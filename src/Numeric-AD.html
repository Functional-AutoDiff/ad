<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<!-- Generated by HsColour, http://code.haskell.org/~malcolm/hscolour/ -->
<title>src/Numeric/AD.hs</title>
<link type='text/css' rel='stylesheet' href='hscolour.css' />
</head>
<body>
<pre><a name="line-1"></a><span class='hs-comment'>{-# LANGUAGE FlexibleContexts #-}</span>
<a name="line-2"></a><span class='hs-comment'>{-# LANGUAGE Rank2Types #-}</span>
<a name="line-3"></a><span class='hs-comment'>{-# LANGUAGE TypeFamilies #-}</span>
<a name="line-4"></a><span class='hs-comment'>{-# LANGUAGE PatternGuards #-}</span>
<a name="line-5"></a><span class='hs-comment'>-----------------------------------------------------------------------------</span>
<a name="line-6"></a><span class='hs-comment'>-- |</span>
<a name="line-7"></a><span class='hs-comment'>-- Copyright   :  (c) Edward Kmett 2010-2014</span>
<a name="line-8"></a><span class='hs-comment'>-- License     :  BSD3</span>
<a name="line-9"></a><span class='hs-comment'>-- Maintainer  :  ekmett@gmail.com</span>
<a name="line-10"></a><span class='hs-comment'>-- Stability   :  experimental</span>
<a name="line-11"></a><span class='hs-comment'>-- Portability :  GHC only</span>
<a name="line-12"></a><span class='hs-comment'>--</span>
<a name="line-13"></a><span class='hs-comment'>-- Mixed-Mode Automatic Differentiation.</span>
<a name="line-14"></a><span class='hs-comment'>--</span>
<a name="line-15"></a><span class='hs-comment'>-- Each combinator exported from this module chooses an appropriate AD mode.</span>
<a name="line-16"></a><span class='hs-comment'>-- The following basic operations are supported, modified as appropriate by the suffixes below:</span>
<a name="line-17"></a><span class='hs-comment'>--</span>
<a name="line-18"></a><span class='hs-comment'>-- * 'grad' computes the gradient (partial derivatives) of a function at a point</span>
<a name="line-19"></a><span class='hs-comment'>--</span>
<a name="line-20"></a><span class='hs-comment'>-- * 'jacobian' computes the Jacobian matrix of a function at a point</span>
<a name="line-21"></a><span class='hs-comment'>--</span>
<a name="line-22"></a><span class='hs-comment'>-- * 'diff' computes the derivative of a function at a point</span>
<a name="line-23"></a><span class='hs-comment'>--</span>
<a name="line-24"></a><span class='hs-comment'>-- * 'du' computes a directional derivative of a function at a point</span>
<a name="line-25"></a><span class='hs-comment'>--</span>
<a name="line-26"></a><span class='hs-comment'>-- * 'hessian' compute the Hessian matrix (matrix of second partial derivatives) of a function at a point</span>
<a name="line-27"></a><span class='hs-comment'>--</span>
<a name="line-28"></a><span class='hs-comment'>-- The suffixes have the following meanings:</span>
<a name="line-29"></a><span class='hs-comment'>--</span>
<a name="line-30"></a><span class='hs-comment'>-- * @\'@ -- also return the answer</span>
<a name="line-31"></a><span class='hs-comment'>--</span>
<a name="line-32"></a><span class='hs-comment'>-- * @With@ lets the user supply a function to blend the input with the output</span>
<a name="line-33"></a><span class='hs-comment'>--</span>
<a name="line-34"></a><span class='hs-comment'>-- * @F@ is a version of the base function lifted to return a 'Traversable' (or 'Functor') result</span>
<a name="line-35"></a><span class='hs-comment'>--</span>
<a name="line-36"></a><span class='hs-comment'>-- * @s@ means the function returns all higher derivatives in a list or f-branching 'Stream'</span>
<a name="line-37"></a><span class='hs-comment'>--</span>
<a name="line-38"></a><span class='hs-comment'>-- * @T@ means the result is transposed with respect to the traditional formulation.</span>
<a name="line-39"></a><span class='hs-comment'>--</span>
<a name="line-40"></a><span class='hs-comment'>-- * @0@ means that the resulting derivative list is padded with 0s at the end.</span>
<a name="line-41"></a><span class='hs-comment'>-----------------------------------------------------------------------------</span>
<a name="line-42"></a>
<a name="line-43"></a><span class='hs-keyword'>module</span> <span class='hs-conid'>Numeric</span><span class='hs-varop'>.</span><span class='hs-conid'>AD</span>
<a name="line-44"></a>  <span class='hs-layout'>(</span>
<a name="line-45"></a>    <span class='hs-comment'>-- * Gradients (Reverse Mode)</span>
<a name="line-46"></a>    <span class='hs-varid'>grad</span>
<a name="line-47"></a>  <span class='hs-layout'>,</span> <span class='hs-varid'>grad'</span>
<a name="line-48"></a>  <span class='hs-layout'>,</span> <span class='hs-varid'>gradWith</span>
<a name="line-49"></a>  <span class='hs-layout'>,</span> <span class='hs-varid'>gradWith'</span>
<a name="line-50"></a>
<a name="line-51"></a>  <span class='hs-comment'>-- * Higher Order Gradients (Sparse-on-Reverse)</span>
<a name="line-52"></a>  <span class='hs-layout'>,</span> <span class='hs-varid'>grads</span>
<a name="line-53"></a>
<a name="line-54"></a>  <span class='hs-comment'>-- * Jacobians (Sparse or Reverse)</span>
<a name="line-55"></a>  <span class='hs-layout'>,</span> <span class='hs-varid'>jacobian</span>
<a name="line-56"></a>  <span class='hs-layout'>,</span> <span class='hs-varid'>jacobian'</span>
<a name="line-57"></a>  <span class='hs-layout'>,</span> <span class='hs-varid'>jacobianWith</span>
<a name="line-58"></a>  <span class='hs-layout'>,</span> <span class='hs-varid'>jacobianWith'</span>
<a name="line-59"></a>
<a name="line-60"></a>  <span class='hs-comment'>-- * Higher Order Jacobian (Sparse-on-Reverse)</span>
<a name="line-61"></a>  <span class='hs-layout'>,</span> <span class='hs-varid'>jacobians</span>
<a name="line-62"></a>
<a name="line-63"></a>  <span class='hs-comment'>-- * Transposed Jacobians (Forward Mode)</span>
<a name="line-64"></a>  <span class='hs-layout'>,</span> <span class='hs-varid'>jacobianT</span>
<a name="line-65"></a>  <span class='hs-layout'>,</span> <span class='hs-varid'>jacobianWithT</span>
<a name="line-66"></a>
<a name="line-67"></a>  <span class='hs-comment'>-- * Hessian (Sparse-On-Reverse)</span>
<a name="line-68"></a>  <span class='hs-layout'>,</span> <span class='hs-varid'>hessian</span>
<a name="line-69"></a>  <span class='hs-layout'>,</span> <span class='hs-varid'>hessian'</span>
<a name="line-70"></a>
<a name="line-71"></a>  <span class='hs-comment'>-- * Hessian Tensors (Sparse or Sparse-On-Reverse)</span>
<a name="line-72"></a>  <span class='hs-layout'>,</span> <span class='hs-varid'>hessianF</span>
<a name="line-73"></a>  <span class='hs-comment'>-- * Hessian Tensors (Sparse)</span>
<a name="line-74"></a>  <span class='hs-layout'>,</span> <span class='hs-varid'>hessianF'</span>
<a name="line-75"></a>
<a name="line-76"></a>  <span class='hs-comment'>-- * Hessian Vector Products (Forward-On-Reverse)</span>
<a name="line-77"></a>  <span class='hs-layout'>,</span> <span class='hs-varid'>hessianProduct</span>
<a name="line-78"></a>  <span class='hs-layout'>,</span> <span class='hs-varid'>hessianProduct'</span>
<a name="line-79"></a>
<a name="line-80"></a>  <span class='hs-comment'>-- * Derivatives (Forward Mode)</span>
<a name="line-81"></a>  <span class='hs-layout'>,</span> <span class='hs-varid'>diff</span>
<a name="line-82"></a>  <span class='hs-layout'>,</span> <span class='hs-varid'>diffF</span>
<a name="line-83"></a>
<a name="line-84"></a>  <span class='hs-layout'>,</span> <span class='hs-varid'>diff'</span>
<a name="line-85"></a>  <span class='hs-layout'>,</span> <span class='hs-varid'>diffF'</span>
<a name="line-86"></a>
<a name="line-87"></a>  <span class='hs-comment'>-- * Derivatives (Tower)</span>
<a name="line-88"></a>  <span class='hs-layout'>,</span> <span class='hs-varid'>diffs</span>
<a name="line-89"></a>  <span class='hs-layout'>,</span> <span class='hs-varid'>diffsF</span>
<a name="line-90"></a>
<a name="line-91"></a>  <span class='hs-layout'>,</span> <span class='hs-varid'>diffs0</span>
<a name="line-92"></a>  <span class='hs-layout'>,</span> <span class='hs-varid'>diffs0F</span>
<a name="line-93"></a>
<a name="line-94"></a>  <span class='hs-comment'>-- * Directional Derivatives (Forward Mode)</span>
<a name="line-95"></a>  <span class='hs-layout'>,</span> <span class='hs-varid'>du</span>
<a name="line-96"></a>  <span class='hs-layout'>,</span> <span class='hs-varid'>du'</span>
<a name="line-97"></a>  <span class='hs-layout'>,</span> <span class='hs-varid'>duF</span>
<a name="line-98"></a>  <span class='hs-layout'>,</span> <span class='hs-varid'>duF'</span>
<a name="line-99"></a>
<a name="line-100"></a>  <span class='hs-comment'>-- * Directional Derivatives (Tower)</span>
<a name="line-101"></a>  <span class='hs-layout'>,</span> <span class='hs-varid'>dus</span>
<a name="line-102"></a>  <span class='hs-layout'>,</span> <span class='hs-varid'>dus0</span>
<a name="line-103"></a>  <span class='hs-layout'>,</span> <span class='hs-varid'>dusF</span>
<a name="line-104"></a>  <span class='hs-layout'>,</span> <span class='hs-varid'>dus0F</span>
<a name="line-105"></a>
<a name="line-106"></a>  <span class='hs-comment'>-- * Taylor Series (Tower)</span>
<a name="line-107"></a>  <span class='hs-layout'>,</span> <span class='hs-varid'>taylor</span>
<a name="line-108"></a>  <span class='hs-layout'>,</span> <span class='hs-varid'>taylor0</span>
<a name="line-109"></a>
<a name="line-110"></a>  <span class='hs-comment'>-- * Maclaurin Series (Tower)</span>
<a name="line-111"></a>  <span class='hs-layout'>,</span> <span class='hs-varid'>maclaurin</span>
<a name="line-112"></a>  <span class='hs-layout'>,</span> <span class='hs-varid'>maclaurin0</span>
<a name="line-113"></a>
<a name="line-114"></a>  <span class='hs-comment'>-- * Gradient Descent</span>
<a name="line-115"></a>  <span class='hs-layout'>,</span> <span class='hs-varid'>gradientDescent</span>
<a name="line-116"></a>  <span class='hs-layout'>,</span> <span class='hs-varid'>gradientAscent</span>
<a name="line-117"></a>  <span class='hs-layout'>,</span> <span class='hs-varid'>conjugateGradientDescent</span>
<a name="line-118"></a>  <span class='hs-layout'>,</span> <span class='hs-varid'>conjugateGradientAscent</span>
<a name="line-119"></a>
<a name="line-120"></a>  <span class='hs-comment'>-- * AD modes</span>
<a name="line-121"></a>  <span class='hs-layout'>,</span> <span class='hs-conid'>Mode</span><span class='hs-layout'>(</span><span class='hs-varid'>auto</span><span class='hs-layout'>)</span>
<a name="line-122"></a>  <span class='hs-layout'>,</span> <span class='hs-conid'>Scalar</span>
<a name="line-123"></a>  <span class='hs-layout'>)</span> <span class='hs-keyword'>where</span>
<a name="line-124"></a>
<a name="line-125"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Control</span><span class='hs-varop'>.</span><span class='hs-conid'>Applicative</span>
<a name="line-126"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Data</span><span class='hs-varop'>.</span><span class='hs-conid'>Functor</span><span class='hs-varop'>.</span><span class='hs-conid'>Compose</span>
<a name="line-127"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Data</span><span class='hs-varop'>.</span><span class='hs-conid'>Traversable</span> <span class='hs-layout'>(</span><span class='hs-conid'>Traversable</span><span class='hs-layout'>)</span>
<a name="line-128"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Data</span><span class='hs-varop'>.</span><span class='hs-conid'>Reflection</span> <span class='hs-layout'>(</span><span class='hs-conid'>Reifies</span><span class='hs-layout'>)</span>
<a name="line-129"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Numeric</span><span class='hs-varop'>.</span><span class='hs-conid'>AD</span><span class='hs-varop'>.</span><span class='hs-conid'>Internal</span><span class='hs-varop'>.</span><span class='hs-conid'>Forward</span> <span class='hs-layout'>(</span><span class='hs-conid'>Forward</span><span class='hs-layout'>)</span>
<a name="line-130"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Numeric</span><span class='hs-varop'>.</span><span class='hs-conid'>AD</span><span class='hs-varop'>.</span><span class='hs-conid'>Internal</span><span class='hs-varop'>.</span><span class='hs-conid'>On</span>
<a name="line-131"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Numeric</span><span class='hs-varop'>.</span><span class='hs-conid'>AD</span><span class='hs-varop'>.</span><span class='hs-conid'>Internal</span><span class='hs-varop'>.</span><span class='hs-conid'>Reverse</span> <span class='hs-layout'>(</span><span class='hs-conid'>Reverse</span><span class='hs-layout'>,</span> <span class='hs-conid'>Tape</span><span class='hs-layout'>)</span>
<a name="line-132"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Numeric</span><span class='hs-varop'>.</span><span class='hs-conid'>AD</span><span class='hs-varop'>.</span><span class='hs-conid'>Internal</span><span class='hs-varop'>.</span><span class='hs-conid'>Sparse</span> <span class='hs-layout'>(</span><span class='hs-conid'>Sparse</span><span class='hs-layout'>)</span>
<a name="line-133"></a>
<a name="line-134"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Numeric</span><span class='hs-varop'>.</span><span class='hs-conid'>AD</span><span class='hs-varop'>.</span><span class='hs-conid'>Mode</span>
<a name="line-135"></a>
<a name="line-136"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Numeric</span><span class='hs-varop'>.</span><span class='hs-conid'>AD</span><span class='hs-varop'>.</span><span class='hs-conid'>Mode</span><span class='hs-varop'>.</span><span class='hs-conid'>Forward</span>
<a name="line-137"></a>  <span class='hs-layout'>(</span> <span class='hs-varid'>diff</span><span class='hs-layout'>,</span> <span class='hs-varid'>diff'</span><span class='hs-layout'>,</span> <span class='hs-varid'>diffF</span><span class='hs-layout'>,</span> <span class='hs-varid'>diffF'</span>
<a name="line-138"></a>  <span class='hs-layout'>,</span> <span class='hs-varid'>du</span><span class='hs-layout'>,</span> <span class='hs-varid'>du'</span><span class='hs-layout'>,</span> <span class='hs-varid'>duF</span><span class='hs-layout'>,</span> <span class='hs-varid'>duF'</span>
<a name="line-139"></a>  <span class='hs-layout'>,</span> <span class='hs-varid'>jacobianT</span><span class='hs-layout'>,</span> <span class='hs-varid'>jacobianWithT</span> <span class='hs-layout'>)</span>
<a name="line-140"></a>
<a name="line-141"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Numeric</span><span class='hs-varop'>.</span><span class='hs-conid'>AD</span><span class='hs-varop'>.</span><span class='hs-conid'>Mode</span><span class='hs-varop'>.</span><span class='hs-conid'>Tower</span>
<a name="line-142"></a>  <span class='hs-layout'>(</span> <span class='hs-varid'>diffsF</span><span class='hs-layout'>,</span> <span class='hs-varid'>diffs0F</span><span class='hs-layout'>,</span> <span class='hs-varid'>diffs</span><span class='hs-layout'>,</span> <span class='hs-varid'>diffs0</span>
<a name="line-143"></a>  <span class='hs-layout'>,</span> <span class='hs-varid'>taylor</span><span class='hs-layout'>,</span> <span class='hs-varid'>taylor0</span><span class='hs-layout'>,</span> <span class='hs-varid'>maclaurin</span><span class='hs-layout'>,</span> <span class='hs-varid'>maclaurin0</span>
<a name="line-144"></a>  <span class='hs-layout'>,</span> <span class='hs-varid'>dus</span><span class='hs-layout'>,</span> <span class='hs-varid'>dus0</span><span class='hs-layout'>,</span> <span class='hs-varid'>dusF</span><span class='hs-layout'>,</span> <span class='hs-varid'>dus0F</span> <span class='hs-layout'>)</span>
<a name="line-145"></a>
<a name="line-146"></a><span class='hs-keyword'>import</span> <span class='hs-keyword'>qualified</span> <span class='hs-conid'>Numeric</span><span class='hs-varop'>.</span><span class='hs-conid'>AD</span><span class='hs-varop'>.</span><span class='hs-conid'>Mode</span><span class='hs-varop'>.</span><span class='hs-conid'>Reverse</span> <span class='hs-keyword'>as</span> <span class='hs-conid'>Reverse</span>
<a name="line-147"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Numeric</span><span class='hs-varop'>.</span><span class='hs-conid'>AD</span><span class='hs-varop'>.</span><span class='hs-conid'>Mode</span><span class='hs-varop'>.</span><span class='hs-conid'>Reverse</span>
<a name="line-148"></a>  <span class='hs-layout'>(</span> <span class='hs-varid'>grad</span><span class='hs-layout'>,</span> <span class='hs-varid'>grad'</span><span class='hs-layout'>,</span> <span class='hs-varid'>gradWith</span><span class='hs-layout'>,</span> <span class='hs-varid'>gradWith'</span><span class='hs-layout'>)</span>
<a name="line-149"></a>
<a name="line-150"></a><span class='hs-comment'>-- temporary until we make a full sparse mode</span>
<a name="line-151"></a><span class='hs-keyword'>import</span> <span class='hs-keyword'>qualified</span> <span class='hs-conid'>Numeric</span><span class='hs-varop'>.</span><span class='hs-conid'>AD</span><span class='hs-varop'>.</span><span class='hs-conid'>Mode</span><span class='hs-varop'>.</span><span class='hs-conid'>Sparse</span> <span class='hs-keyword'>as</span> <span class='hs-conid'>Sparse</span>
<a name="line-152"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Numeric</span><span class='hs-varop'>.</span><span class='hs-conid'>AD</span><span class='hs-varop'>.</span><span class='hs-conid'>Mode</span><span class='hs-varop'>.</span><span class='hs-conid'>Sparse</span>
<a name="line-153"></a>  <span class='hs-layout'>(</span> <span class='hs-varid'>grads</span><span class='hs-layout'>,</span> <span class='hs-varid'>jacobians</span><span class='hs-layout'>,</span> <span class='hs-varid'>hessian'</span><span class='hs-layout'>,</span> <span class='hs-varid'>hessianF'</span><span class='hs-layout'>)</span>
<a name="line-154"></a>
<a name="line-155"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Numeric</span><span class='hs-varop'>.</span><span class='hs-conid'>AD</span><span class='hs-varop'>.</span><span class='hs-conid'>Newton</span>
<a name="line-156"></a>
<a name="line-157"></a><a name="jacobian"></a><span class='hs-comment'>-- | Calculate the Jacobian of a non-scalar-to-non-scalar function, automatically choosing between sparse and Reverse mode AD.</span>
<a name="line-158"></a><span class='hs-comment'>--</span>
<a name="line-159"></a><span class='hs-comment'>-- If you know that you have relatively many outputs per input, consider using 'Numeric.AD.Sparse.jacobian'.</span>
<a name="line-160"></a><span class='hs-comment'>--</span>
<a name="line-161"></a><span class='hs-comment'>-- &gt;&gt;&gt; jacobian (\[x,y] -&gt; [y,x,x+y,x*y,exp x * sin y]) [pi,1]</span>
<a name="line-162"></a><span class='hs-comment'>-- [[0.0,1.0],[1.0,0.0],[1.0,1.0],[1.0,3.141592653589793],[19.472221418841606,12.502969588876512]]</span>
<a name="line-163"></a><span class='hs-definition'>jacobian</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>Traversable</span> <span class='hs-varid'>f</span><span class='hs-layout'>,</span> <span class='hs-conid'>Functor</span> <span class='hs-varid'>g</span><span class='hs-layout'>,</span> <span class='hs-conid'>Num</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-layout'>(</span><span class='hs-keyword'>forall</span> <span class='hs-varid'>s</span><span class='hs-varop'>.</span> <span class='hs-conid'>Reifies</span> <span class='hs-varid'>s</span> <span class='hs-conid'>Tape</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-varid'>f</span> <span class='hs-layout'>(</span><span class='hs-conid'>Reverse</span> <span class='hs-varid'>a</span> <span class='hs-varid'>s</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>g</span> <span class='hs-layout'>(</span><span class='hs-conid'>Reverse</span> <span class='hs-varid'>a</span> <span class='hs-varid'>s</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>f</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>g</span> <span class='hs-layout'>(</span><span class='hs-varid'>f</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span>
<a name="line-164"></a><span class='hs-definition'>jacobian</span> <span class='hs-varid'>f</span> <span class='hs-varid'>bs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>snd</span> <span class='hs-varop'>&lt;$&gt;</span> <span class='hs-varid'>jacobian'</span> <span class='hs-varid'>f</span> <span class='hs-varid'>bs</span>
<a name="line-165"></a><span class='hs-comment'>{-# INLINE jacobian #-}</span>
<a name="line-166"></a>
<a name="line-167"></a><a name="jacobian'"></a><span class='hs-comment'>-- | Calculate both the answer and Jacobian of a non-scalar-to-non-scalar function, using reverse-mode AD.</span>
<a name="line-168"></a><span class='hs-comment'>--</span>
<a name="line-169"></a><span class='hs-comment'>-- If you have relatively many outputs per input, consider using 'Numeric.AD.Sparse.jacobian''.</span>
<a name="line-170"></a><span class='hs-definition'>jacobian'</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>Traversable</span> <span class='hs-varid'>f</span><span class='hs-layout'>,</span> <span class='hs-conid'>Functor</span> <span class='hs-varid'>g</span><span class='hs-layout'>,</span> <span class='hs-conid'>Num</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-layout'>(</span><span class='hs-keyword'>forall</span> <span class='hs-varid'>s</span><span class='hs-varop'>.</span> <span class='hs-conid'>Reifies</span> <span class='hs-varid'>s</span> <span class='hs-conid'>Tape</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-varid'>f</span> <span class='hs-layout'>(</span><span class='hs-conid'>Reverse</span> <span class='hs-varid'>a</span> <span class='hs-varid'>s</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>g</span> <span class='hs-layout'>(</span><span class='hs-conid'>Reverse</span> <span class='hs-varid'>a</span> <span class='hs-varid'>s</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>f</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>g</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span><span class='hs-layout'>,</span> <span class='hs-varid'>f</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span>
<a name="line-171"></a><span class='hs-definition'>jacobian'</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Reverse</span><span class='hs-varop'>.</span><span class='hs-varid'>jacobian'</span>
<a name="line-172"></a><span class='hs-comment'>{-# INLINE jacobian' #-}</span>
<a name="line-173"></a>
<a name="line-174"></a><a name="jacobianWith"></a><span class='hs-comment'>-- | @'jacobianWith' g f@ calculates the Jacobian of a non-scalar-to-non-scalar function, using Reverse mode AD.</span>
<a name="line-175"></a><span class='hs-comment'>--</span>
<a name="line-176"></a><span class='hs-comment'>-- The resulting Jacobian matrix is then recombined element-wise with the input using @g@.</span>
<a name="line-177"></a><span class='hs-comment'>--</span>
<a name="line-178"></a><span class='hs-comment'>-- If you know that you have relatively many outputs per input, consider using 'Numeric.AD.Sparse.jacobianWith'.</span>
<a name="line-179"></a><span class='hs-definition'>jacobianWith</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>Traversable</span> <span class='hs-varid'>f</span><span class='hs-layout'>,</span> <span class='hs-conid'>Functor</span> <span class='hs-varid'>g</span><span class='hs-layout'>,</span> <span class='hs-conid'>Num</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-keyword'>forall</span> <span class='hs-varid'>s</span><span class='hs-varop'>.</span> <span class='hs-conid'>Reifies</span> <span class='hs-varid'>s</span> <span class='hs-conid'>Tape</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-varid'>f</span> <span class='hs-layout'>(</span><span class='hs-conid'>Reverse</span> <span class='hs-varid'>a</span> <span class='hs-varid'>s</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>g</span> <span class='hs-layout'>(</span><span class='hs-conid'>Reverse</span> <span class='hs-varid'>a</span> <span class='hs-varid'>s</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>f</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>g</span> <span class='hs-layout'>(</span><span class='hs-varid'>f</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span>
<a name="line-180"></a><span class='hs-definition'>jacobianWith</span> <span class='hs-varid'>g</span> <span class='hs-varid'>f</span> <span class='hs-varid'>bs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>snd</span> <span class='hs-varop'>&lt;$&gt;</span> <span class='hs-varid'>jacobianWith'</span> <span class='hs-varid'>g</span> <span class='hs-varid'>f</span> <span class='hs-varid'>bs</span>
<a name="line-181"></a><span class='hs-comment'>{-# INLINE jacobianWith #-}</span>
<a name="line-182"></a>
<a name="line-183"></a><a name="jacobianWith'"></a><span class='hs-comment'>-- | @'jacobianWith'' g f@ calculates the answer and Jacobian of a non-scalar-to-non-scalar function, using Reverse mode AD.</span>
<a name="line-184"></a><span class='hs-comment'>--</span>
<a name="line-185"></a><span class='hs-comment'>-- The resulting Jacobian matrix is then recombined element-wise with the input using @g@.</span>
<a name="line-186"></a><span class='hs-comment'>--</span>
<a name="line-187"></a><span class='hs-comment'>-- If you know that you have relatively many outputs per input, consider using 'Numeric.AD.Sparse.jacobianWith''.</span>
<a name="line-188"></a><span class='hs-definition'>jacobianWith'</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>Traversable</span> <span class='hs-varid'>f</span><span class='hs-layout'>,</span> <span class='hs-conid'>Functor</span> <span class='hs-varid'>g</span><span class='hs-layout'>,</span> <span class='hs-conid'>Num</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-keyword'>forall</span> <span class='hs-varid'>s</span><span class='hs-varop'>.</span> <span class='hs-conid'>Reifies</span> <span class='hs-varid'>s</span> <span class='hs-conid'>Tape</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-varid'>f</span> <span class='hs-layout'>(</span><span class='hs-conid'>Reverse</span> <span class='hs-varid'>a</span> <span class='hs-varid'>s</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>g</span> <span class='hs-layout'>(</span><span class='hs-conid'>Reverse</span> <span class='hs-varid'>a</span> <span class='hs-varid'>s</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>f</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>g</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span><span class='hs-layout'>,</span> <span class='hs-varid'>f</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span>
<a name="line-189"></a><span class='hs-definition'>jacobianWith'</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Reverse</span><span class='hs-varop'>.</span><span class='hs-varid'>jacobianWith'</span>
<a name="line-190"></a><span class='hs-comment'>{-# INLINE jacobianWith' #-}</span>
<a name="line-191"></a>
<a name="line-192"></a><a name="hessianProduct"></a><span class='hs-comment'>-- | @'hessianProduct' f wv@ computes the product of the hessian @H@ of a non-scalar-to-scalar function @f@ at @w = 'fst' &lt;$&gt; wv@ with a vector @v = snd &lt;$&gt; wv@ using \"Pearlmutter\'s method\" from &lt;<a href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.29.6143">http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.29.6143</a>&gt;, which states:</span>
<a name="line-193"></a><span class='hs-comment'>--</span>
<a name="line-194"></a><span class='hs-comment'>-- &gt; H v = (d/dr) grad_w (w + r v) | r = 0</span>
<a name="line-195"></a><span class='hs-comment'>--</span>
<a name="line-196"></a><span class='hs-comment'>-- Or in other words, we take the directional derivative of the gradient. The gradient is calculated in reverse mode, then the directional derivative is calculated in forward mode.</span>
<a name="line-197"></a><span class='hs-comment'>--</span>
<a name="line-198"></a><span class='hs-definition'>hessianProduct</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>Traversable</span> <span class='hs-varid'>f</span><span class='hs-layout'>,</span> <span class='hs-conid'>Num</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-layout'>(</span><span class='hs-keyword'>forall</span> <span class='hs-varid'>s</span> <span class='hs-varid'>s'</span><span class='hs-varop'>.</span> <span class='hs-conid'>Reifies</span> <span class='hs-varid'>s</span> <span class='hs-conid'>Tape</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-varid'>f</span> <span class='hs-layout'>(</span><span class='hs-conid'>On</span> <span class='hs-layout'>(</span><span class='hs-conid'>Reverse</span> <span class='hs-layout'>(</span><span class='hs-conid'>Forward</span> <span class='hs-varid'>a</span> <span class='hs-varid'>s'</span><span class='hs-layout'>)</span> <span class='hs-varid'>s</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>On</span> <span class='hs-layout'>(</span><span class='hs-conid'>Reverse</span> <span class='hs-layout'>(</span><span class='hs-conid'>Forward</span> <span class='hs-varid'>a</span> <span class='hs-varid'>s'</span><span class='hs-layout'>)</span> <span class='hs-varid'>s</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>f</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span><span class='hs-layout'>,</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>f</span> <span class='hs-varid'>a</span>
<a name="line-199"></a><span class='hs-definition'>hessianProduct</span> <span class='hs-varid'>f</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>duF</span> <span class='hs-layout'>(</span><span class='hs-varid'>grad</span> <span class='hs-layout'>(</span><span class='hs-varid'>off</span> <span class='hs-varop'>.</span> <span class='hs-varid'>f</span> <span class='hs-varop'>.</span> <span class='hs-varid'>fmap</span> <span class='hs-conid'>On</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-200"></a>
<a name="line-201"></a><a name="hessianProduct'"></a><span class='hs-comment'>-- | @'hessianProduct'' f wv@ computes both the gradient of a non-scalar-to-scalar @f@ at @w = 'fst' &lt;$&gt; wv@ and the product of the hessian @H@ at @w@ with a vector @v = snd &lt;$&gt; wv@ using \"Pearlmutter's method\". The outputs are returned wrapped in the same functor.</span>
<a name="line-202"></a><span class='hs-comment'>--</span>
<a name="line-203"></a><span class='hs-comment'>-- &gt; H v = (d/dr) grad_w (w + r v) | r = 0</span>
<a name="line-204"></a><span class='hs-comment'>--</span>
<a name="line-205"></a><span class='hs-comment'>-- Or in other words, we return the gradient and the directional derivative of the gradient. The gradient is calculated in reverse mode, then the directional derivative is calculated in forward mode.</span>
<a name="line-206"></a><span class='hs-definition'>hessianProduct'</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>Traversable</span> <span class='hs-varid'>f</span><span class='hs-layout'>,</span> <span class='hs-conid'>Num</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-layout'>(</span><span class='hs-keyword'>forall</span> <span class='hs-varid'>s</span> <span class='hs-varid'>s'</span><span class='hs-varop'>.</span> <span class='hs-conid'>Reifies</span> <span class='hs-varid'>s</span> <span class='hs-conid'>Tape</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-varid'>f</span> <span class='hs-layout'>(</span><span class='hs-conid'>On</span> <span class='hs-layout'>(</span><span class='hs-conid'>Reverse</span> <span class='hs-layout'>(</span><span class='hs-conid'>Forward</span> <span class='hs-varid'>a</span> <span class='hs-varid'>s'</span><span class='hs-layout'>)</span> <span class='hs-varid'>s</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>On</span> <span class='hs-layout'>(</span><span class='hs-conid'>Reverse</span> <span class='hs-layout'>(</span><span class='hs-conid'>Forward</span> <span class='hs-varid'>a</span> <span class='hs-varid'>s'</span><span class='hs-layout'>)</span> <span class='hs-varid'>s</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>f</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span><span class='hs-layout'>,</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>f</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span><span class='hs-layout'>,</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span>
<a name="line-207"></a><span class='hs-definition'>hessianProduct'</span> <span class='hs-varid'>f</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>duF'</span> <span class='hs-layout'>(</span><span class='hs-varid'>grad</span> <span class='hs-layout'>(</span><span class='hs-varid'>off</span> <span class='hs-varop'>.</span> <span class='hs-varid'>f</span> <span class='hs-varop'>.</span> <span class='hs-varid'>fmap</span> <span class='hs-conid'>On</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-208"></a>
<a name="line-209"></a><a name="hessian"></a><span class='hs-comment'>-- | Compute the Hessian via the Jacobian of the gradient. gradient is computed in reverse mode and then the Jacobian is computed in sparse (forward) mode.</span>
<a name="line-210"></a><span class='hs-comment'>--</span>
<a name="line-211"></a><span class='hs-comment'>-- &gt;&gt;&gt; hessian (\[x,y] -&gt; x*y) [1,2]</span>
<a name="line-212"></a><span class='hs-comment'>-- [[0,1],[1,0]]</span>
<a name="line-213"></a><span class='hs-definition'>hessian</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>Traversable</span> <span class='hs-varid'>f</span><span class='hs-layout'>,</span> <span class='hs-conid'>Num</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-layout'>(</span><span class='hs-keyword'>forall</span> <span class='hs-varid'>s</span> <span class='hs-varid'>s'</span><span class='hs-varop'>.</span> <span class='hs-conid'>Reifies</span> <span class='hs-varid'>s</span> <span class='hs-conid'>Tape</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-varid'>f</span> <span class='hs-layout'>(</span><span class='hs-conid'>On</span> <span class='hs-layout'>(</span><span class='hs-conid'>Reverse</span> <span class='hs-layout'>(</span><span class='hs-conid'>Sparse</span> <span class='hs-varid'>a</span> <span class='hs-varid'>s'</span><span class='hs-layout'>)</span> <span class='hs-varid'>s</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>On</span> <span class='hs-layout'>(</span><span class='hs-conid'>Reverse</span> <span class='hs-layout'>(</span><span class='hs-conid'>Sparse</span> <span class='hs-varid'>a</span> <span class='hs-varid'>s'</span><span class='hs-layout'>)</span> <span class='hs-varid'>s</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>f</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>f</span> <span class='hs-layout'>(</span><span class='hs-varid'>f</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span>
<a name="line-214"></a><span class='hs-definition'>hessian</span> <span class='hs-varid'>f</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Sparse</span><span class='hs-varop'>.</span><span class='hs-varid'>jacobian</span> <span class='hs-layout'>(</span><span class='hs-varid'>grad</span> <span class='hs-layout'>(</span><span class='hs-varid'>off</span> <span class='hs-varop'>.</span> <span class='hs-varid'>f</span> <span class='hs-varop'>.</span> <span class='hs-varid'>fmap</span> <span class='hs-conid'>On</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-215"></a>
<a name="line-216"></a><a name="hessianF"></a><span class='hs-comment'>-- | Compute the order 3 Hessian tensor on a non-scalar-to-non-scalar function using 'Sparse'-on-'Reverse'</span>
<a name="line-217"></a><span class='hs-comment'>--</span>
<a name="line-218"></a><span class='hs-comment'>-- &gt;&gt;&gt; hessianF (\[x,y] -&gt; [x*y,x+y,exp x*cos y]) [1,2]</span>
<a name="line-219"></a><span class='hs-comment'>-- [[[0.0,1.0],[1.0,0.0]],[[0.0,0.0],[0.0,0.0]],[[-1.1312043837568135,-2.4717266720048188],[-2.4717266720048188,1.1312043837568135]]]</span>
<a name="line-220"></a><span class='hs-definition'>hessianF</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>Traversable</span> <span class='hs-varid'>f</span><span class='hs-layout'>,</span> <span class='hs-conid'>Functor</span> <span class='hs-varid'>g</span><span class='hs-layout'>,</span> <span class='hs-conid'>Num</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-layout'>(</span><span class='hs-keyword'>forall</span> <span class='hs-varid'>s</span> <span class='hs-varid'>s'</span><span class='hs-varop'>.</span> <span class='hs-conid'>Reifies</span> <span class='hs-varid'>s</span> <span class='hs-conid'>Tape</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-varid'>f</span> <span class='hs-layout'>(</span><span class='hs-conid'>On</span> <span class='hs-layout'>(</span><span class='hs-conid'>Reverse</span> <span class='hs-layout'>(</span><span class='hs-conid'>Sparse</span> <span class='hs-varid'>a</span> <span class='hs-varid'>s'</span><span class='hs-layout'>)</span> <span class='hs-varid'>s</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>g</span> <span class='hs-layout'>(</span><span class='hs-conid'>On</span> <span class='hs-layout'>(</span><span class='hs-conid'>Reverse</span> <span class='hs-layout'>(</span><span class='hs-conid'>Sparse</span> <span class='hs-varid'>a</span> <span class='hs-varid'>s'</span><span class='hs-layout'>)</span> <span class='hs-varid'>s</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>f</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>g</span> <span class='hs-layout'>(</span><span class='hs-varid'>f</span> <span class='hs-layout'>(</span><span class='hs-varid'>f</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-221"></a><span class='hs-definition'>hessianF</span> <span class='hs-varid'>f</span> <span class='hs-keyword'>as</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>getCompose</span> <span class='hs-varop'>$</span> <span class='hs-conid'>Sparse</span><span class='hs-varop'>.</span><span class='hs-varid'>jacobian</span> <span class='hs-layout'>(</span><span class='hs-conid'>Compose</span> <span class='hs-varop'>.</span> <span class='hs-conid'>Reverse</span><span class='hs-varop'>.</span><span class='hs-varid'>jacobian</span> <span class='hs-layout'>(</span><span class='hs-varid'>fmap</span> <span class='hs-varid'>off</span> <span class='hs-varop'>.</span> <span class='hs-varid'>f</span> <span class='hs-varop'>.</span> <span class='hs-varid'>fmap</span> <span class='hs-conid'>On</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-keyword'>as</span>
</pre></body>
</html>
